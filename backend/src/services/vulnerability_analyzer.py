"""
Vulnerability Analyzer Service
Correlates NVD vulnerabilities with SuperOps device inventory and patch data
"""
import os
import re
import json
import boto3
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import logging
from ..integrations.nvd_client import NVDClient
from ..integrations.superops_client import SuperOpsClient

logger = logging.getLogger(__name__)


class VulnerabilityAnalyzer:
    def __init__(self):
        self.nvd_client = NVDClient()
        self.superops_client = SuperOpsClient()
        
        # AWS Services
        self.sns_client = boto3.client('sns', region_name=os.getenv('AWS_REGION', 'us-east-1'))
        self.dynamodb = boto3.resource('dynamodb', region_name=os.getenv('AWS_REGION', 'us-east-1'))
        self.eventbridge = boto3.client('events', region_name=os.getenv('AWS_REGION', 'us-east-1'))
        
        # DynamoDB table for vulnerability tracking
        self.vulnerability_table_name = os.getenv('VULNERABILITY_TABLE', 'AutoOps-Vulnerabilities')
        self.alert_topic_arn = os.getenv('ALERT_SNS_TOPIC_ARN', '')

    def analyze_device_vulnerabilities(self, device_id: Optional[str] = None) -> List[Dict]:
        """
        Analyze vulnerabilities for all devices or specific device
        Cross-references NVD CVEs with device OS/software versions
        """
        try:
            # Get device inventory from SuperOps
            filters = {'deviceId': device_id} if device_id else None
            devices = self.superops_client.get_device_inventory(filters)
            
            # Get recent CVEs from NVD
            recent_cves = self.nvd_client.search_recent_cves(days=30)
            
            vulnerabilities = []
            
            for device in devices:
                device_vulns = self._match_cves_to_device(device, recent_cves)
                
                for vuln in device_vulns:
                    vuln_record = {
                        'deviceId': device['id'],
                        'deviceName': device['name'],
                        'operatingSystem': device.get('operatingSystem', 'Unknown'),
                        'ipAddress': device.get('ipAddress', 'N/A'),
                        'cveId': vuln['cveId'],
                        'cvssScore': vuln['cvssScore'],
                        'severity': vuln['severity'],
                        'description': vuln['description'],
                        'publishedDate': vuln['publishedDate'],
                        'affectedSoftware': vuln['affectedSoftware'],
                        'patchAvailable': False,
                        'analyzedAt': datetime.utcnow().isoformat()
                    }
                    
                    vulnerabilities.append(vuln_record)
                    
                    # Store in DynamoDB
                    self._store_vulnerability(vuln_record)
                    
                    # Send alert if critical
                    if vuln['cvssScore'] >= 9.0:
                        self._send_critical_alert(vuln_record)
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Error analyzing device vulnerabilities: {e}")
            raise

    def _match_cves_to_device(self, device: Dict, cves: List[Dict]) -> List[Dict]:
        """Match CVEs to device based on OS and software"""
        matched_vulns = []
        os_name = device.get('operatingSystem', '').lower()
        
        for cve in cves:
            # Extract OS version from device
            os_version = self._extract_os_version(os_name)
            
            # Check if CVE affects this device's OS
            if self._cve_affects_device(cve, os_name, os_version):
                matched_vulns.append({
                    'cveId': cve.get('id', ''),
                    'cvssScore': cve.get('cvss_score', 0),
                    'severity': cve.get('severity', 'UNKNOWN'),
                    'description': cve.get('description', ''),
                    'publishedDate': cve.get('published_date', ''),
                    'affectedSoftware': cve.get('affected_software', [])
                })
        
        return matched_vulns

    def _extract_os_version(self, os_string: str) -> str:
        """Extract version number from OS string"""
        # Match version patterns like "10.0.19045", "Windows 11", "Ubuntu 22.04"
        version_match = re.search(r'(\d+\.?\d*\.?\d*)', os_string)
        return version_match.group(1) if version_match else ''

    def _cve_affects_device(self, cve: Dict, os_name: str, os_version: str) -> bool:
        """Determine if CVE affects the device"""
        affected_software = cve.get('affected_software', [])
        
        # Check if OS is in affected software list
        for software in affected_software:
            software_lower = software.lower()
            if any(keyword in os_name for keyword in ['windows', 'linux', 'ubuntu', 'redhat', 'centos']):
                if any(keyword in software_lower for keyword in ['windows', 'linux', 'ubuntu', 'redhat', 'centos']):
                    return True
        
        return False

    def analyze_patch_coverage(self) -> Dict:
        """
        Analyze patch coverage across all devices
        Compares available patches with known vulnerabilities
        """
        try:
            # Get patch status from SuperOps
            patch_statuses = self.superops_client.get_patch_status()
            
            # Get vulnerabilities from DynamoDB
            vulnerabilities = self._get_stored_vulnerabilities()
            
            analysis = {
                'totalDevices': len(patch_statuses),
                'fullyPatched': 0,
                'partiallyPatched': 0,
                'unpatched': 0,
                'criticalExposure': [],
                'patchRecommendations': [],
                'coverageRate': 0
            }
            
            for patch_status in patch_statuses:
                device_id = patch_status['deviceId']
                critical_patches = patch_status.get('criticalPatches', [])
                pending = patch_status.get('pendingPatches', 0)
                
                # Match critical patches with CVEs
                device_vulns = [v for v in vulnerabilities if v['deviceId'] == device_id]
                
                # Determine patch status
                if pending == 0:
                    analysis['fullyPatched'] += 1
                elif pending > 0 and len(critical_patches) == 0:
                    analysis['partiallyPatched'] += 1
                else:
                    analysis['unpatched'] += 1
                    
                    # Track critical exposure
                    for vuln in device_vulns:
                        if vuln['cvssScore'] >= 9.0:
                            analysis['criticalExposure'].append({
                                'deviceId': device_id,
                                'deviceName': patch_status['deviceName'],
                                'cveId': vuln['cveId'],
                                'cvssScore': vuln['cvssScore']
                            })
                
                # Generate recommendations
                if len(critical_patches) > 0:
                    analysis['patchRecommendations'].append({
                        'deviceId': device_id,
                        'deviceName': patch_status['deviceName'],
                        'criticalPatches': len(critical_patches),
                        'patches': critical_patches[:5]  # Top 5
                    })
            
            # Calculate coverage rate
            if analysis['totalDevices'] > 0:
                analysis['coverageRate'] = (analysis['fullyPatched'] / analysis['totalDevices']) * 100
            
            return analysis
            
        except Exception as e:
            logger.error(f"Error analyzing patch coverage: {e}")
            raise

    def get_alerts_with_context(self) -> List[Dict]:
        """
        Get alerts from SuperOps enriched with vulnerability context
        """
        try:
            # Get alerts from SuperOps
            alerts = self.superops_client.get_alerts()
            
            # Get vulnerabilities
            vulnerabilities = self._get_stored_vulnerabilities()
            
            enriched_alerts = []
            
            for alert in alerts:
                device_id = alert.get('deviceId')
                
                # Find related vulnerabilities
                related_vulns = [v for v in vulnerabilities if v['deviceId'] == device_id]
                
                enriched_alert = {
                    **alert,
                    'relatedVulnerabilities': len(related_vulns),
                    'criticalVulnerabilities': len([v for v in related_vulns if v['cvssScore'] >= 9.0]),
                    'highVulnerabilities': len([v for v in related_vulns if 7.0 <= v['cvssScore'] < 9.0]),
                    'vulnerabilityDetails': related_vulns[:3]  # Top 3
                }
                
                enriched_alerts.append(enriched_alert)
            
            return enriched_alerts
            
        except Exception as e:
            logger.error(f"Error getting enriched alerts: {e}")
            raise

    def create_alert(self, alert_data: Dict) -> Dict:
        """
        Create a new alert and send notifications via AWS SNS
        """
        try:
            # Create alert in SuperOps (if supported)
            # For now, we'll create a custom alert and send via SNS
            
            alert_id = f"ALERT-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
            
            alert = {
                'alertId': alert_id,
                'title': alert_data.get('title', 'Security Alert'),
                'description': alert_data.get('description', ''),
                'severity': alert_data.get('severity', 'MEDIUM'),
                'deviceId': alert_data.get('deviceId'),
                'deviceName': alert_data.get('deviceName'),
                'cveIds': alert_data.get('cveIds', []),
                'createdAt': datetime.utcnow().isoformat(),
                'status': 'ACTIVE'
            }
            
            # Store in DynamoDB
            self._store_alert(alert)
            
            # Send SNS notification
            self._send_sns_notification(alert)
            
            # Create EventBridge event for automation
            self._send_eventbridge_event(alert)
            
            return alert
            
        except Exception as e:
            logger.error(f"Error creating alert: {e}")
            raise

    def _store_vulnerability(self, vulnerability: Dict):
        """Store vulnerability in DynamoDB"""
        try:
            table = self.dynamodb.Table(self.vulnerability_table_name)
            
            item = {
                'PK': f"DEVICE#{vulnerability['deviceId']}",
                'SK': f"CVE#{vulnerability['cveId']}#{vulnerability['analyzedAt']}",
                'deviceId': vulnerability['deviceId'],
                'deviceName': vulnerability['deviceName'],
                'cveId': vulnerability['cveId'],
                'cvssScore': str(vulnerability['cvssScore']),
                'severity': vulnerability['severity'],
                'description': vulnerability['description'],
                'analyzedAt': vulnerability['analyzedAt'],
                'ttl': int((datetime.utcnow() + timedelta(days=90)).timestamp())
            }
            
            table.put_item(Item=item)
            
        except Exception as e:
            logger.warning(f"Could not store vulnerability in DynamoDB: {e}")

    def _get_stored_vulnerabilities(self, days: int = 7) -> List[Dict]:
        """Retrieve vulnerabilities from DynamoDB"""
        try:
            table = self.dynamodb.Table(self.vulnerability_table_name)
            
            # Scan for recent vulnerabilities
            cutoff_date = (datetime.utcnow() - timedelta(days=days)).isoformat()
            
            response = table.scan(
                FilterExpression='analyzedAt > :cutoff',
                ExpressionAttributeValues={':cutoff': cutoff_date}
            )
            
            return response.get('Items', [])
            
        except Exception as e:
            logger.warning(f"Could not retrieve vulnerabilities from DynamoDB: {e}")
            return []

    def _store_alert(self, alert: Dict):
        """Store alert in DynamoDB"""
        try:
            table = self.dynamodb.Table(self.vulnerability_table_name)
            
            item = {
                'PK': f"ALERT#{alert['alertId']}",
                'SK': f"TIMESTAMP#{alert['createdAt']}",
                **alert
            }
            
            table.put_item(Item=item)
            
        except Exception as e:
            logger.warning(f"Could not store alert in DynamoDB: {e}")

    def _send_critical_alert(self, vulnerability: Dict):
        """Send critical alert via SNS"""
        if not self.alert_topic_arn:
            logger.warning("Alert SNS topic ARN not configured")
            return
        
        try:
            message = f"""
CRITICAL VULNERABILITY DETECTED

Device: {vulnerability['deviceName']} ({vulnerability['deviceId']})
CVE: {vulnerability['cveId']}
CVSS Score: {vulnerability['cvssScore']}
Severity: {vulnerability['severity']}

Description: {vulnerability['description']}

Immediate action required!
"""
            
            self.sns_client.publish(
                TopicArn=self.alert_topic_arn,
                Subject=f"CRITICAL: {vulnerability['cveId']} on {vulnerability['deviceName']}",
                Message=message
            )
            
            logger.info(f"Critical alert sent for {vulnerability['cveId']}")
            
        except Exception as e:
            logger.error(f"Failed to send critical alert: {e}")

    def _send_sns_notification(self, alert: Dict):
        """Send alert notification via SNS"""
        if not self.alert_topic_arn:
            logger.warning("Alert SNS topic ARN not configured")
            return
        
        try:
            message = json.dumps(alert, indent=2)
            
            self.sns_client.publish(
                TopicArn=self.alert_topic_arn,
                Subject=alert['title'],
                Message=message,
                MessageAttributes={
                    'severity': {'DataType': 'String', 'StringValue': alert['severity']},
                    'deviceId': {'DataType': 'String', 'StringValue': alert.get('deviceId', '')}
                }
            )
            
        except Exception as e:
            logger.error(f"Failed to send SNS notification: {e}")

    def _send_eventbridge_event(self, alert: Dict):
        """Send event to EventBridge for automation"""
        try:
            self.eventbridge.put_events(
                Entries=[
                    {
                        'Source': 'autoops.vulnerability.analyzer',
                        'DetailType': 'Vulnerability Alert',
                        'Detail': json.dumps(alert),
                        'EventBusName': 'default'
                    }
                ]
            )
            
            logger.info(f"EventBridge event sent for alert {alert['alertId']}")
            
        except Exception as e:
            logger.error(f"Failed to send EventBridge event: {e}")

    def get_device_inventory_with_vulnerabilities(self) -> List[Dict]:
        """
        Get complete device inventory with vulnerability status
        """
        try:
            devices = self.superops_client.get_device_inventory()
            vulnerabilities = self._get_stored_vulnerabilities(days=30)
            
            inventory = []
            
            for device in devices:
                device_vulns = [v for v in vulnerabilities if v.get('deviceId') == device['id']]
                
                device_info = {
                    'id': device['id'],
                    'name': device['name'],
                    'type': device.get('type', 'Unknown'),
                    'operatingSystem': device.get('operatingSystem', 'Unknown'),
                    'ipAddress': device.get('ipAddress', 'N/A'),
                    'macAddress': device.get('macAddress', 'N/A'),
                    'lastSeenAt': device.get('lastSeenAt', 'N/A'),
                    'client': device.get('client', {}).get('name', 'N/A'),
                    'site': device.get('site', {}).get('name', 'N/A'),
                    'vulnerabilityStats': {
                        'total': len(device_vulns),
                        'critical': len([v for v in device_vulns if float(v.get('cvssScore', 0)) >= 9.0]),
                        'high': len([v for v in device_vulns if 7.0 <= float(v.get('cvssScore', 0)) < 9.0]),
                        'medium': len([v for v in device_vulns if 4.0 <= float(v.get('cvssScore', 0)) < 7.0])
                    },
                    'topVulnerabilities': sorted(device_vulns, key=lambda x: float(x.get('cvssScore', 0)), reverse=True)[:5],
                    'riskScore': self._calculate_risk_score(device_vulns)
                }
                
                inventory.append(device_info)
            
            # Sort by risk score
            inventory.sort(key=lambda x: x['riskScore'], reverse=True)
            
            return inventory
            
        except Exception as e:
            logger.error(f"Error getting device inventory with vulnerabilities: {e}")
            raise

    def _calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """Calculate overall risk score for a device"""
        if not vulnerabilities:
            return 0.0
        
        total_score = 0.0
        for vuln in vulnerabilities:
            cvss = float(vuln.get('cvssScore', 0))
            # Weight more recent vulnerabilities higher
            total_score += cvss
        
        # Normalize to 0-100 scale
        return min(total_score / len(vulnerabilities) * 10, 100.0)
